<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文笔记：《Self-Attentive Sequential Recommendation》</title>
    <url>/2021/11/17/SASRec/</url>
    <content><![CDATA[<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117230533153.png" alt="image-20211117230533153"></p>
<hr>
<p>原paper：<a href="https://ieeexplore.ieee.org/document/8594844">https://ieeexplore.ieee.org/document/8594844</a></p>
<p>源码解读：<a href="https://github.com/Guadzilla/Paper_notebook/tree/main/SASRec">https://github.com/Guadzilla/Paper_notebook/tree/main/SASRec</a></p>
<hr>
<p>中译：自注意序列推荐</p>
<p>总结：比较早使用self-attention的序列推荐模型</p>
<hr>
<span id="more"></span>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>  question作者想解决什么问题？  </li>
</ul>
<p>序列动态是许多当代推荐系统的一个重要特征，它试图根据用户最近执行的操作来捕捉用户活动的“上下文“。RNN模型可以在稠密数据集上捕捉长期语义。（马尔科夫链）MC模型可以在稀疏数据集上仅根据最近几次action做出预测。本文想平衡这两个目标：在稀疏和稠密数据集上做到捕捉长期语义、依赖较少的action做预测。</p>
<ul>
<li>  method作者通过什么理论/模型来解决这个问题？</li>
</ul>
<p>本文提出了一个基于self-attention的序列模型（SASRec），在每个时间步寻找与用户历史最相关的物品作为next item的预测。</p>
<ul>
<li>  answer作者给出的答案是什么？</li>
</ul>
<p>在稀疏和稠密数据集上，与MC/CNN/RNN方法相比都取得了SOTA效果。</p>
<h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><ul>
<li>  why作者为什么研究这个课题？    </li>
</ul>
<p>MC方法模型简单，但因为它的强假设（当前预测仅取决于最近n次）使得它在稀疏数据上表现好，但是不能捕捉更复杂的动态转换。RNN方法需要稠密数据，并且计算复杂。最近出现新的序列模型Transformer，它是基于self-attention的，效率高并且可以捕获句子中单词的句法和语义模式。受self-attention方法启发，应用到序列推荐上。</p>
<ul>
<li>  how当前研究到了哪一阶段？ </li>
</ul>
<p>第一个将transformer里的self-attention应用到了序列推荐上。</p>
<ul>
<li>  what作者基于什么样的假设（看不懂最后去查）？</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>优点 <ul>
<li>  SASRec模型建模了整个序列，自适应地考虑items来预测</li>
<li>  在dense和sparse的数据集上效果都很好</li>
<li>  比CNN/RNN方法快了一个数量级</li>
</ul>
</li>
<li>  缺点</li>
<li>展望<ul>
<li>  引进更多上下文信息，比如等待时间、行为类型、位置、设备等。</li>
<li>  探索处理超长序列（如clicks）的方法</li>
</ul>
</li>
</ul>
<h2 id="Dataset-amp-Metric"><a href="#Dataset-amp-Metric" class="headerlink" title="Dataset &amp; Metric"></a>Dataset &amp; Metric</h2><ul>
<li>数据来源 （都开源）<ul>
<li>  Amazon</li>
<li>  Steam 作者爬的，开源了</li>
<li>  Movielens</li>
</ul>
</li>
<li>重要指标 <ul>
<li>  Hit@10</li>
<li>  NDCG@10</li>
</ul>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>这部分直接转载了知乎[[1]](<a href="https://zhuanlan.zhihu.com/p/277660092?utm_source=qq">推荐算法炼丹笔记：序列化推荐算法SASRec - 知乎 (zhihu.com)</a>)</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211115114043810.png" alt="image-20211115114043810"></p>
<p><strong>1.Embedding层</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-6127cd6bfcdc00f007ba287f11c1f55f_720w.jpg" alt="img"></p>
<p><strong>A. Positional Embedding</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-558fcc53330d91271fc2850a3998e704_720w.jpg" alt="img"></p>
<p><strong>2.Self-Attention Block</strong></p>
<p><strong>A.Self-Attention Layer</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-4ad7a98ce285113021eade4349199c5f_720w.jpg" alt="img"></p>
<p><strong>C.Point-Wise Feed-Forward Network</strong>: 尽管self-attention能将之前item的emebdding使用自适应的权重进行集成，但仍然是一个先线性模型,为了加入非线性能力, 我们使用两层的DDN,</p>
<p><img src="https://pic2.zhimg.com/80/v2-bdfa1cac41b3f4aa676e81d54a72671d_720w.jpg" alt="img"></p>
<p><strong>3.Stacking Self-Attention Blocks</strong></p>
<p>在第一个self-attention block之后,学习item的迁移可以学习更加复杂的item迁移,所以我们对self-attention block进行stacking,第b(b&gt;1)的block可以用下面的形式进行定义：</p>
<p><img src="https://pic3.zhimg.com/80/v2-cdc40ee5705587460d39e19649625942_720w.jpg" alt="img"></p>
<p><strong>4.Prediction Layer</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-873157dd4336dcbbd818227c7ced3f25_720w.jpg" alt="img"></p>
<p>使用同质(homogeneous)商品embedding的一个潜在问题是，它们的内部产品不能代表不对称的商品转换。然而，我们的模型没有这个问题，因为它学习了一个非线性变换。例如，前馈网络可以很容易地实现同项嵌入的不对称性,<strong>经验上使用共享的商品embedding也可以大大提升模型的效果;</strong></p>
<p><strong>显示的用户建模</strong>：为了提供个性化的推荐,现有的方法常用两种方法,(1).学习显示的用户embedding表示用户的喜好;(2).考虑之前的行为并且引入隐式的用户embedding。此处使用并没有带来提升。</p>
<p><strong>5.网络训练</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-684099a2a86837c0b3ad701ea2169710_720w.jpg" alt="img"></p>
<p><strong>6.方案复杂度分析</strong></p>
<p><strong>a. 空间复杂度</strong></p>
<p>模型中学习的参数来自于self-attention.ffn以及layer normalization的参数,总的参数为:</p>
<p><img src="https://pic4.zhimg.com/80/v2-3d4d8db1c48964728a0c6830ecc4a71b_720w.jpg" alt="img"></p>
<p><strong>b. 时间复杂度</strong></p>
<p>我们模型的计算复杂度主要在于self-attention layer和FFN网络,</p>
<p><img src="https://pic1.zhimg.com/80/v2-1cd0b2b09e9bc3fba57281ab76f2d478_720w.jpg" alt="img"></p>
<p>里面最耗时间的还是self-attention layer, 不过这个可以进行并行化。</p>
<h2 id="Experiment-amp-Table"><a href="#Experiment-amp-Table" class="headerlink" title="Experiment &amp; Table"></a>Experiment &amp; Table</h2><p>该次实验主要为了验证下面的四个问题：</p>
<ol>
<li>是否SASRec比现有最好的模型(CNN/RNN)要好？</li>
<li>在SASRec框架中不同的成份的影响怎么样？</li>
<li>SASRec的训练效率和可扩展性怎么样？</li>
<li>attention的权重是否可以学习得到关于位置和商品属性的有意义的模式?</li>
</ol>
<p><strong>1. 推荐效果比较</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-e789c62c7c2e998f0713341ebc43155f_720w.jpg" alt="img"></p>
<ul>
<li>SASRec在稀疏的和dense的数据集合熵比所有的baseline都要好, 获得了6.9%的Hit Rate提升以及9.6%的NDCG提升；</li>
</ul>
<p><strong>2. SASRec框架中不同成份的影响</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-155ea54d12922a3d1aafcece005b5731_720w.jpg" alt="img"></p>
<ul>
<li>删除PE: 删除位置embedding ,在稀疏的数据集上,删除PE效果变好,但是在稠密的数据集上,删除PE的效果变差了。</li>
<li>不共享IE(Item Embedding): 使用共享的item embedding比不使用要好很多;</li>
<li>删除RC(Residual Connection):不实用残差连接,性能会变差非常多;</li>
<li>删除Dropout: dropout可以帮助模型,尤其是在稀疏的数据集上,Dropout的作用更加明显;</li>
<li>blocks的个数：没有block的时候,效果最差,在dense数据集上,相比稀疏数据多一些block的效果好一些;</li>
<li>Multi-head:在我们数据集上,single-head效果最好.</li>
</ul>
<p><strong>3. SASRec的训练效率和可扩展性</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-b4a0692c6cf9b0a335dae79eba2ed723_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1a7f5f0f47c7ada0e2ccd22b23078584_720w.jpg" alt="img"></p>
<ul>
<li>SASRec是最快的;</li>
<li>序列长度可以扩展至500左右.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/277660092?utm_source=qq">[1]推荐算法炼丹笔记：序列化推荐算法SASRec</a></p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>序列推荐</tag>
        <tag>SASRec</tag>
        <tag>自注意力</tag>
      </tags>
  </entry>
  <entry>
    <title>SASRec代码笔记</title>
    <url>/2021/11/18/SASRec%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>完整的代码注释在：<a href="https://github.com/Guadzilla/Paper_notebook/tree/main/SASRec">https://github.com/Guadzilla/Paper_notebook/tree/main/SASRec</a></p>
<h2 id="collections-defaultdict-list"><a href="#collections-defaultdict-list" class="headerlink" title="collections.defaultdict(list)"></a>collections.defaultdict(list)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">result = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">data = [(<span class="string">&quot;p&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;p&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;p&quot;</span>, <span class="number">3</span>),</span><br><span class="line">        (<span class="string">&quot;h&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;h&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;h&quot;</span>, <span class="number">3</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> data:</span><br><span class="line">    result[key].append(value)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(result)<span class="comment">#defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;p&#x27;: [1, 2, 3], &#x27;h&#x27;: [1, 2, 3]&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Python自定义多线程"><a href="#Python自定义多线程" class="headerlink" title="Python自定义多线程"></a>Python自定义多线程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_neq</span>(<span class="params">l, r, s</span>):</span></span><br><span class="line">    t = np.random.randint(l, r)</span><br><span class="line">    <span class="keyword">while</span> t <span class="keyword">in</span> s:</span><br><span class="line">        t = np.random.randint(l, r)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_function</span>(<span class="params">user_train, usernum, itemnum, batch_size, maxlen, result_queue, SEED</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span>():</span></span><br><span class="line"></span><br><span class="line">        user = np.random.randint(<span class="number">1</span>, usernum + <span class="number">1</span>)    <span class="comment"># 随机采样user id，注意是从1开始的</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(user_train[user]) &lt;= <span class="number">1</span>: user = np.random.randint(<span class="number">1</span>, usernum + <span class="number">1</span>)  <span class="comment"># 长度小于1的训练集不要</span></span><br><span class="line"></span><br><span class="line">        seq = np.zeros([maxlen], dtype=np.int32)    <span class="comment"># seq序列，长度固定为maxlen，用0在前面padding补上长度，例：[0,0,...,0,23,15,2,6]</span></span><br><span class="line">        pos = np.zeros([maxlen], dtype=np.int32)</span><br><span class="line">        neg = np.zeros([maxlen], dtype=np.int32)</span><br><span class="line">        nxt = user_train[user][-<span class="number">1</span>]  <span class="comment"># user_train的最后一个item取为nxt</span></span><br><span class="line">        idx = maxlen - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ts = <span class="built_in">set</span>(user_train[user])  <span class="comment"># ts为序列的item集合</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(user_train[user][:-<span class="number">1</span>]):   <span class="comment"># 从后往前遍历user_train,idx为当前要填充的下标</span></span><br><span class="line">            seq[idx] = i</span><br><span class="line">            pos[idx] = nxt</span><br><span class="line">            <span class="keyword">if</span> nxt != <span class="number">0</span>: neg[idx] = random_neq(<span class="number">1</span>, itemnum + <span class="number">1</span>, ts)  <span class="comment"># 生成的负样本不能取该序列item集合里的item</span></span><br><span class="line">            nxt = i</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> idx == -<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (user, seq, pos, neg)    <span class="comment"># 返回一次采样，(用户id,训练序列，label序列，负样本序列)</span></span><br><span class="line"></span><br><span class="line">    np.random.seed(SEED)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:     <span class="comment"># 采样一个batch_size大小的数据样本，打包成一个batch，放到线程队列里</span></span><br><span class="line">        one_batch = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">            one_batch.append(sample())</span><br><span class="line"></span><br><span class="line">        result_queue.put(<span class="built_in">zip</span>(*one_batch))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarpSampler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, User, usernum, itemnum, batch_size=<span class="number">64</span>, maxlen=<span class="number">10</span>, n_workers=<span class="number">1</span></span>):</span></span><br><span class="line">        self.result_queue = Queue(maxsize=n_workers * <span class="number">10</span>)   <span class="comment"># 长度为10的线程队列</span></span><br><span class="line">        self.processors = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_workers):</span><br><span class="line">            self.processors.append(     <span class="comment"># Process()进程的类, target：要调用的对象即sampler_function，args：调用该对象要接受的参数</span></span><br><span class="line">                Process(target=sample_function, args=(User,</span><br><span class="line">                                                      usernum,</span><br><span class="line">                                                      itemnum,</span><br><span class="line">                                                      batch_size,</span><br><span class="line">                                                      maxlen,</span><br><span class="line">                                                      self.result_queue,</span><br><span class="line">                                                      np.random.randint(<span class="number">2e9</span>)</span><br><span class="line">                                                      )))</span><br><span class="line">            self.processors[-<span class="number">1</span>].daemon = <span class="literal">True</span></span><br><span class="line">            self.processors[-<span class="number">1</span>].start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_batch</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.result_queue.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> self.processors:</span><br><span class="line">            p.terminate()</span><br><span class="line">            p.join()</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment"># sampler是WarpSampler对象的实例，每次调用sampler.next_batch(),就返回一个batch的样本。</span></span><br><span class="line"><span class="comment"># 进一步解释：每次调用sampler.next_batch()就call其线程队列里的一个线程，每个线程用于返回一个batch的数据。</span></span><br><span class="line">sampler = WarpSampler(user_train, usernum, itemnum, batch_size=args.batch_size, maxlen=args.maxlen, n_workers=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h2 id="torch-tril"><a href="#torch-tril" class="headerlink" title="torch.tril()"></a>torch.tril()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tril(<span class="built_in">input</span>, diagonal=<span class="number">0</span>, *, out=<span class="literal">None</span>) → Tensor</span><br><span class="line"><span class="comment"># 功能：返回下三角矩阵其余部分用out填充（默认为0）</span></span><br><span class="line"><span class="comment"># input：输入矩阵，二维tensor</span></span><br><span class="line"><span class="comment"># diagonal：表示对角线位置，diagonal=0为主对角线，diagonal=-1为主对角线往下1格，diagonal=1为主对角线往上1格</span></span><br><span class="line"><span class="comment"># out：表示填充，默认用out=None即0填充</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([[-<span class="number">1.0813</span>, -<span class="number">0.8619</span>,  <span class="number">0.7105</span>],</span><br><span class="line">        [ <span class="number">0.0935</span>,  <span class="number">0.1380</span>,  <span class="number">2.2112</span>],</span><br><span class="line">        [-<span class="number">0.3409</span>, -<span class="number">0.9828</span>,  <span class="number">0.0289</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.tril(a)</span><br><span class="line">tensor([[-<span class="number">1.0813</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">0.0935</span>,  <span class="number">0.1380</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [-<span class="number">0.3409</span>, -<span class="number">0.9828</span>,  <span class="number">0.0289</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.randn(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">tensor([[ <span class="number">1.2219</span>,  <span class="number">0.5653</span>, -<span class="number">0.2521</span>, -<span class="number">0.2345</span>,  <span class="number">1.2544</span>,  <span class="number">0.3461</span>],</span><br><span class="line">        [ <span class="number">0.4785</span>, -<span class="number">0.4477</span>,  <span class="number">0.6049</span>,  <span class="number">0.6368</span>,  <span class="number">0.8775</span>,  <span class="number">0.7145</span>],</span><br><span class="line">        [ <span class="number">1.1502</span>,  <span class="number">3.2716</span>, -<span class="number">1.1243</span>, -<span class="number">0.5413</span>,  <span class="number">0.3615</span>,  <span class="number">0.6864</span>],</span><br><span class="line">        [-<span class="number">0.0614</span>, -<span class="number">0.7344</span>, -<span class="number">1.3164</span>, -<span class="number">0.7648</span>, -<span class="number">1.4024</span>,  <span class="number">0.0978</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.tril(b, diagonal=<span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">1.2219</span>,  <span class="number">0.5653</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">0.4785</span>, -<span class="number">0.4477</span>,  <span class="number">0.6049</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">1.1502</span>,  <span class="number">3.2716</span>, -<span class="number">1.1243</span>, -<span class="number">0.5413</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [-<span class="number">0.0614</span>, -<span class="number">0.7344</span>, -<span class="number">1.3164</span>, -<span class="number">0.7648</span>, -<span class="number">1.4024</span>,  <span class="number">0.0000</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.tril(b, diagonal=-<span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">0.4785</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">1.1502</span>,  <span class="number">3.2716</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [-<span class="number">0.0614</span>, -<span class="number">0.7344</span>, -<span class="number">1.3164</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>]])</span><br></pre></td></tr></table></figure>



<h2 id="Python中的-波浪线运算符"><a href="#Python中的-波浪线运算符" class="headerlink" title="Python中的 ~ 波浪线运算符"></a>Python中的 ~ 波浪线运算符</h2><p>~，用法只有一个那就是按位取反</p>
<p><a href="https://blog.csdn.net/lanchunhui/article/details/51746477"> Python 波浪线与补码_https://space.bilibili.com/59807853-CSDN博客_python 波浪线</a></p>
<h2 id="torch-nn-MultiAttention"><a href="#torch-nn-MultiAttention" class="headerlink" title="torch.nn.MultiAttention"></a>torch.nn.MultiAttention</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.MultiheadAttention(embed_dim, num_heads, dropout=<span class="number">0.0</span>, bias=<span class="literal">True</span>, add_bias_kv=<span class="literal">False</span>, add_zero_attn=<span class="literal">False</span>, kdim=<span class="literal">None</span>, vdim=<span class="literal">None</span>, batch_first=<span class="literal">False</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应公式：<br>$$<br>Multihead(Q,K,V) = Concat(head_1,…,head_h)W^O    \<br>where \quad head_i= Attention(QW^Q_i,KW^K_i,VW^V_i)<br>$$</p>
<p>计算公式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">forward(query, key, value, key_padding_mask=<span class="literal">None</span>, need_weights=<span class="literal">True</span>, attn_mask=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>QKV比较常规，需要注意的是</p>
<ol>
<li>key_padding_mask参数，大小为（N，S），指定key中的哪些元素不做attention计算，即看作padding。注意，为True的位置不计算attention（是padding的地方不计算）</li>
<li>attn_mask参数，</li>
</ol>
<h2 id="torch-nn-BCEWithLogitsLoss"><a href="#torch-nn-BCEWithLogitsLoss" class="headerlink" title="torch.nn.BCEWithLogitsLoss()"></a>torch.nn.BCEWithLogitsLoss()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forward(self, input: Tensor, target: Tensor) -&gt; Tensor</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>input: Tensor of arbitrary shape as unnormalized scores (often referred to as logits).</li>
<li>target: Tensor of the same shape as input with values between 0 and 1</li>
</ul>
<p>input：$x$        output：$y$</p>
<p>$ℓ(x,y)=L={l_1,…,l_N}^T\l_n=−w_n[y_n·log\sigma(x_n)+(1−y_n)·log(1−\sigma(x_n))]$</p>
<p>当 $y=1$ 时，$l_n=−log\sigma(x_n)$  ；当 $y=0$ 时，$l_n=−log(1-\sigma(x_n))$     。</p>
<p>论文里使用了一个全1的矩阵pos_labels，和一个全0的矩阵neg_labels。正例标签值都为1（正确的item，ground truth应该是概率为1），负例标签值都为0（错误的item，ground truth应该是概率为0）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pos_labels, neg_labels = torch.ones(pos_logits.shape, device=args.device), \</span><br><span class="line">torch.zeros(neg_logits.shape, device=args.device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;\neye ball check raw_logits:&quot;); print(pos_logits); print(neg_logits)</span></span><br><span class="line"><span class="comment"># check pos_logits &gt; 0, neg_logits &lt; 0</span></span><br><span class="line">adam_optimizer.zero_grad()</span><br><span class="line">indices = np.where(pos != <span class="number">0</span>)    <span class="comment"># 返回一个二维数组array， array[0]=[横坐标], array[1]=[纵坐标]</span></span><br><span class="line">loss = bce_criterion(pos_logits[indices], pos_labels[indices])  <span class="comment"># 使正例的得分尽量</span></span><br><span class="line">loss += bce_criterion(neg_logits[indices], neg_labels[indices])</span><br></pre></td></tr></table></figure>



<h2 id="torch-argsort"><a href="#torch-argsort" class="headerlink" title="torch.argsort()"></a>torch.argsort()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.argsort(<span class="built_in">input</span>, dim=-<span class="number">1</span>, descending=<span class="literal">False</span>) → LongTensor</span><br></pre></td></tr></table></figure>

<p>沿着指定dim从小到大（默认）排序元素，然后返回这些元素原来的下标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;t = torch.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">&gt;&gt;&gt;t</span><br><span class="line">tensor([[<span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]])</span><br><span class="line">&gt;&gt;&gt;t.argsort()</span><br><span class="line">tensor([[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">&gt;&gt;&gt;t.argsort().argsort()</span><br><span class="line">tensor([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两次argsort()可以返回每个元素的rank排名</span></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># 把商品0,1,2,3,4按顺序摆好，他们的得分分别为[7,9,5,6,3]</span></span><br><span class="line"><span class="comment"># 对所有商品的得分从小到大排序（argsort()操作）</span></span><br><span class="line"><span class="comment"># 得到积分排名是[3,5,6,7,9]，积分排名对应的商品id是[4,2,3,0,1]（第一次argsort()的结果），每个商品id对应的下标就是他们的得分名次</span></span><br><span class="line"><span class="comment"># 例如商品4得分最高排在第一位，商品1得分最低排最后一位</span></span><br><span class="line"><span class="comment"># 然后我们想得到0,1,2,3,4顺序下的结果</span></span><br><span class="line"><span class="comment"># 所以对商品id排序，使得商品摆放顺序由[4,2,3,0,1]变为[0,1,2,3,4]，这里也是argsort()操作，因为0~4天然有顺序关系</span></span><br><span class="line"><span class="comment"># [4,2,3,0,1]变为[0,1,2,3,4]的同时，排名情况[0,1,2,3,4]也变成了[3,4,1,2,0]（第二次argsort()的结果）</span></span><br><span class="line"><span class="comment"># 即求得每个商品在原来顺序下的得分名次</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/traditional/p/13702904.html">numpy中的argmax、argmin、argwhere、argsort、argpartition函数 - 古明地盆 - 博客园 (cnblogs.com)</a></p>
<h2 id="评价指标Hit-Ratio、NDCG-1"><a href="#评价指标Hit-Ratio、NDCG-1" class="headerlink" title="评价指标Hit Ratio、NDCG[1]"></a>评价指标Hit Ratio、NDCG<a href="https://dl.acm.org/doi/10.1145/2806416.2806504">[1]</a></h2><h3 id="Hit-Ratio"><a href="#Hit-Ratio" class="headerlink" title="Hit Ratio"></a>Hit Ratio</h3><p>Evaluation Metrics. Given a user, each algorithm produces a ranked list of items. To assess the ranked list with the ground-truth item set (GT), we adopt Hit Ratio (HR), which has been commonly used in top-N evaluation . If a test item appears in the recommended list, it is deemed a hit. HR is calculated as:<br>$$<br>HR@K=\frac{Number\ of \  Hits@K}{|GT|}<br>$$</p>
<h3 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h3><p>As the HR is recall-based metric, it does not reflect the accuracy of getting top ranks correct, which is crucial in many real-world applications. To address this, we also adopt Normalized Discounted Cumulative Gain (NDCG), which assigns higher importance to results at top ranks, scoring successively lower ranks with marginal fractional utility:<br>$$<br>NDCG@K=Z_K\sum^K_{i=1}\frac{2^{r_i}-1}{log_2{(i+1)}}<br>$$<br>where ZK is the normalizer to ensure the perfect ranking has a value of 1; ri is the graded relevance of item at position i. We use the simple binary relevance for our work: ri = 1 if the item is in the test set, and 0 otherwise. For both metrics, larger values indicate better performance. In the evaluation, we calculate both metrics for each user in the test set, and report the average score.</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># evaluate on test set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">model, dataset, args</span>):</span></span><br><span class="line">    [train, valid, test, usernum, itemnum] = copy.deepcopy(dataset)  <span class="comment"># deepcopy一份用于valid和test</span></span><br><span class="line"></span><br><span class="line">    NDCG = <span class="number">0.0</span></span><br><span class="line">    HT = <span class="number">0.0</span></span><br><span class="line">    valid_user = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> usernum &gt; <span class="number">10000</span>:  <span class="comment"># 用户数量大于10000就随机采10000</span></span><br><span class="line">        users = random.sample(<span class="built_in">range</span>(<span class="number">1</span>, usernum + <span class="number">1</span>), <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        users = <span class="built_in">range</span>(<span class="number">1</span>, usernum + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> users:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(train[u]) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(test[u]) &lt; <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        seq = np.zeros([args.maxlen], dtype=np.int32)</span><br><span class="line">        idx = args.maxlen - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 假设原始序列为[1,2,3,4,5,6,7]    6用于valid；7用于test</span></span><br><span class="line">        seq[idx] = valid[u][<span class="number">0</span>]  <span class="comment"># seq: [0,0,0,...,0,0,0,6]</span></span><br><span class="line">        idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(train[u]):  <span class="comment"># seq: [0,0,0,...,0,1,2,3,4,5,6]  只剩test里的[7]用于预测</span></span><br><span class="line">            seq[idx] = i</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> idx == -<span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        rated = <span class="built_in">set</span>(train[u])  <span class="comment"># 序列物品集合</span></span><br><span class="line">        rated.add(<span class="number">0</span>)</span><br><span class="line">        item_idx = [test[u][<span class="number">0</span>]]  <span class="comment"># 取出ground truth label</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># item_idx: [label,random,random,...,random] 1+100个随机物品，看得分在top10的情况</span></span><br><span class="line">            t = np.random.randint(<span class="number">1</span>, itemnum + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> t <span class="keyword">in</span> rated: t = np.random.randint(<span class="number">1</span>, itemnum + <span class="number">1</span>)</span><br><span class="line">            item_idx.append(t)</span><br><span class="line"></span><br><span class="line">        predictions = -model.predict(*[np.array(l) <span class="keyword">for</span> l <span class="keyword">in</span> [[u], [seq], item_idx]])</span><br><span class="line">        predictions = predictions[<span class="number">0</span>]  <span class="comment"># (1,101) -&gt; 101 (squeeze)</span></span><br><span class="line"></span><br><span class="line">        rank = predictions.argsort().argsort()[<span class="number">0</span>].item()  <span class="comment"># 做两次argsort()，可以得到每个位置的rank排名</span></span><br><span class="line"></span><br><span class="line">        valid_user += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rank &lt; <span class="number">10</span>:  <span class="comment"># TOP10才记录，这里真实rank = rank + 1 ，因为argsort()索引包含0</span></span><br><span class="line">            NDCG += <span class="number">1</span> / np.log2(rank + <span class="number">2</span>)</span><br><span class="line">            HT += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> valid_user % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="comment"># sys.stdout.flush()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NDCG / valid_user, HT / valid_user</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://dl.acm.org/doi/10.1145/2806416.2806504">[1]He X, Chen T, Kan M Y, et al. Trirank: Review-aware explainable recommendation by modeling aspects</a></p>
]]></content>
      <categories>
        <category>代码阅读</category>
      </categories>
      <tags>
        <tag>SASRec</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记：《Time Interval Aware Self-Attention for Sequential Recommendation》</title>
    <url>/2021/11/17/TiSASRec/</url>
    <content><![CDATA[<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117164643993.png"></p>
<hr>
<p>原paper：<a href="https://dl.acm.org/doi/10.1145/3336191.3371786">https://dl.acm.org/doi/10.1145/3336191.3371786</a></p>
<p>源码解读：占坑</p>
<hr>
<p>中译：时间间隔感知的自注意力序列推荐</p>
<p>总结：是SASRec工作的延续，在self-attention的基础上加了绝对位置信息和相对时间间隔信息（加在Q和K里）取得了更好的performamce。发现Beauty数据集序列模式不明显。</p>
<span id="more"></span>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>  <strong>question作者想解决什么问题？</strong></li>
</ul>
<p>MC模型和RNN模型都只将用户交互作为有序序列（一种强假设），却没有考虑交互与交互之间的时间间隔。</p>
<ul>
<li>  <strong>method作者通过什么理论/模型来解决这个问题？</strong></li>
</ul>
<p>在序列模型的结构中显式建模交互的时间戳（timestamps），并且探索不同时间间隔对next item推荐的影响。提出TiSASRec模型，模型建模了item在序列中的绝对位置以及交互之间的时间间隔。</p>
<ul>
<li>  <strong>answer作者给出的答案是什么？</strong></li>
</ul>
<p>展示了不同设定下TiSASRec的特点，比较了不同位置编码下自注意力模块的表现。在dense和sparse数据集都取得了SOTA。</p>
<h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><ul>
<li>  <strong>why作者为什么研究这个课题？</strong></li>
</ul>
<p>Temporal recommendation（实时推荐）主要建模“绝对时间”来捕获用户与物品的实时动态，即挖掘实时模式、依据时间建模。Sequential recommendation（序列推荐）主要依据交互的顺序挖掘序列模式。序列推荐只用timestamps来决定item顺序，其实假设了所有交互之间是等间隔的。但一天之内产生的序列和一个月内产生的序列显然对next item的影响区别很大。</p>
<ul>
<li>  <strong>how当前研究到了哪一阶段</strong></li>
</ul>
<p>目前的序列推荐只挖掘序列模式，即假设交互之间是等间隔的，不合理。有模型使用自注意力+相对位置编码[1]，受到启发。</p>
<ul>
<li>  <strong>what作者基于什么样的假设（看不懂最后去查）</strong></li>
</ul>
<p>交互序列应该被建模为包含时间间隔的序列。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li><p><strong>优点</strong></p>
<ul>
<li>  结合了<strong>绝对位置编码</strong>和<strong>相对时间间隔</strong>编码的优点。</li>
<li>  证明了使用相对时间间隔的有效性。</li>
</ul>
</li>
<li><p>  <strong>缺点</strong></p>
</li>
<li><p>  <strong>展望</strong></p>
</li>
</ul>
<h2 id="Dataset-amp-Metric"><a href="#Dataset-amp-Metric" class="headerlink" title="Dataset &amp; Metric"></a>Dataset &amp; Metric</h2><ul>
<li><p><strong>数据来源</strong></p>
<ul>
<li>  MovieLens-1m</li>
<li>  Amazon CDs&amp;Vinyl/ Movies&amp;TV/ Beauty/ Games</li>
<li>  Steam</li>
</ul>
</li>
<li><p><strong>重要指标</strong></p>
<ul>
<li>  Hit@10、NDCG@10</li>
</ul>
</li>
</ul>
<h2 id="Method-amp-Table"><a href="#Method-amp-Table" class="headerlink" title="Method &amp; Table"></a>Method &amp; Table</h2><ul>
<li>模型架构</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211116223143274.png"></p>
<ul>
<li>参数说明</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211116223530787.png" alt="image-20211116223530787"></p>
<p><strong>1.个性化的时间间隔（time interval）</strong></p>
<p>规定了序列$S$的maxlen（n），小于n的用items来padding。但是时间序列$T$用第一个item的timestamps来padding（到这里还只是时间戳）。</p>
<p>对每个用户制定个性化的时间间隔。对用户$u$来说，时间戳序列$t=(t_1,t_2,…,t_n)$，用任意两个物品的时间戳之差表示物品之间的时间间隔，作为任意两个物品之间的关系（relation）$r_{ij}$，得到时间间隔集合$R^u$。规定一个缩放系数$r^u_{min}=min(R^u)$，即序列里的最小时间间隔，再对所有时间间隔缩放$r^u_{ij}=\lfloor\frac{|r_i-r_j|}{r^u_{min}}\rfloor$，得到时间间隔矩阵$M^u\in N^{n\times n}$。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211116225152019.png" alt="image-20211116225152019"></p>
<p>还规定了每个$r^u_{ij}$的阈值，对大于阈值的做了一个clip操作得到$M^u_{clipped}$。</p>
<p><strong>2.Embedding层</strong></p>
<ul>
<li>item的表示：padding item用$\vec0$表示，其它每个item用d维向量表示，构成$M^I\in R^{|I|\times d}$的item embedding矩阵，则前n个item的表示为$E^I\in R^{n\times d}$。</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117222616679.png" alt="image-20211117222616679"></p>
<ul>
<li>position 的表示：即位置编码，用两个K、V矩阵$M^P_K\in R^{n\times d}$和$M^P_V\in R^{n\times d}$，表示每个位置（序列最大长度为n）的Key和Value向量，分别为$E^P_K\in R^{n\times d}$和$E^P_V\in R^{n\times d}$。</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117081419839.png" alt="image-20211117081419839"></p>
<ul>
<li>relative time interval的表示：和positional embedding相似，用两个K、V矩阵$E^P_K\in R^{k\times d}$和$E^P_V\in R^{k\times d}$，表示每个位置（序列最大长度为n）的Key和Value向量，其中k表示一共有k种相对时间间隔。于是clipped后的$M^u_{clipped}$，把对应的$r_{ij}$替换成对应的K、V向量，就得到了$E^R_K\in R^{n\times n\times d}$和$E^R_V\in R^{n\times n\times d}$。</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117081413089.png" alt="image-20211117081413089"></p>
<p><strong>3.时间间隔感知的自注意力机制</strong></p>
<p>仅有item和对应的时间戳也不能把序列确定下来，还要加入item在序列中的位置。</p>
<ul>
<li><strong>时间间隔感知的自注意力层Time Interval-Aware Self-attention Layer</strong></li>
</ul>
<p>传统的自注意力层为QKV模式，可以定义成$Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V$。用item embedding乘以$W^Q、W^K、W^V$投影到其对应的$Querry、Key、Value$空间上。</p>
<p>这里本质上也是这么做的，但对K和V做了一点改变。</p>
<p>作者首先将$E^I=(m_{s_1},m_{s_2},…,m_{s_n})$表示的item序列变换新序列$Z=(z_1,z_2,…,z_n)$，$z_i\in R^d$。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117222727853.png" alt="image-20211117222727853"></p>
<p>其中$(m_{s_j}W^V+r_{ij}^v+p_j^v)$**对应QKV模式里的$Value$**，其中$m_{s_j}W^Q$是将item embedding投影到$Value$空间，不过在此基础上还加上了realation embedding（相对时间间隔）和position embedding（位置编码）的value表示。</p>
<p>找到$Value$以后，公式就可以写成：$z_i=\sum^n_{j=1}\alpha_{ij}\ Value_j$。</p>
<p>系数$\alpha_{ij}$是其实就是$softmax(\frac{QK^T}{\sqrt{d_k}})$部分。$softmax()$在论文中体现在$\alpha_{ij}=\frac{exp\ e_{ij}}{\sum^n_{k=1}exp\ e_{ik}}$，那么可以猜测$\frac{QK^T}{\sqrt{d_k}}$就对应论文中的$e_{ij}$了。事实正如此，$e_{ij}$被定义为：</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117090739720.png" alt="image-20211117090739720"></p>
<p>其中$m_{s_j}W^Q$是将item embedding投影到$Querry$空间，**对应QKV模式里的$Querry$**。</p>
<p>$(m_{s_j}W^K+r^k_{ij}+p^k_j)$，**对应QKV模式里的$Key$**，其中$m_{s_j}W^K$是将item embedding投影到$Key$空间，不过在此基础上还加上了realation embedding（相对时间间隔）和position embedding（位置编码）的key表示，另外除以的$\sqrt{d}$是缩放系数。</p>
<ul>
<li><strong>因果关系Causality</strong></li>
</ul>
<p>序列本身就有因果关系，因为我们在预测第t+1个物品时，只知道前t个物品的信息。但是在做self-attention时，每个物品都能感知到所有物品（因为Q对所有K做了查询），破坏了因果关系。所以我们必须规定，在做self-attention时，规定每个$Q_i$只能查询$K_j$，其中$j&lt;i$，即每个Q只能查询在其之前（previous）的K，满足了因果关系，代码里可以用mask实现。</p>
<ul>
<li><strong>前馈层Point-wise Feef-Forward Network</strong></li>
</ul>
<p>FFN为模型加入非线性性。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117093429227.png" alt="image-20211117093429227"></p>
<p>Residual connection和dropout正则化。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117093655881.png" alt="image-20211117093655881"></p>
<p>Layer Norm正则化。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117093809122.png" alt="image-20211117093809122"></p>
<p><strong>4.预测层</strong></p>
<p>常规的点积计算每个物品的得分。</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117094112160.png" alt="image-20211117094112160"></p>
<p><strong>5.模型训练</strong></p>
<p>取物品序列$\widetilde{S_{|S^u|}}=(S^u_1,S^u_2,…,S^u_{|S^u|})$和对应的时间序列$\widetilde{T_{|T^u|}}=(T^u_1,T^u_2,…,T^u_{|T^u|})$的前$|S^u|-1$项，即$\widetilde{S_{|S^u|-1}}=(S^=u_1,S^u_2,…,S^u_{|S^u|-1})$和$\widetilde{T_{|T^u|-1}}=(T^u_1,T^u_2,…,T^u_{|T^u-1|})$。通过裁剪和补长各自化成成相同长度n的两个序列$s=(s_1,s_2,…,s_n)$，和$t=(t_1,t_2,…,t_n)$。给定这两个序列，再规定对应的输出序列$o=(o_1,o_2,…,o_n)$，其中$o_i$定义为：</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117095415283.png" alt="image-20211117095415283"></p>
<p>简而言之，padding项的输出为&lt;pad&gt;；$s$最后一项之前的输出（预测）为下一项；$s$最后一项的输出（预测）为$S^u_{|S^u|}$，注意$S^u_{|S^u|}$不在$s$里，因为一开始就把最后一项拿出来了。</p>
<p>loss采用进行负采样的binary cross entropy，加入了F正则项：</p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117100703091.png" alt="image-20211117100703091"></p>
<p>padding项也计算了loss，但是没有意义，所以实际计算时把padding项的loss mask掉。</p>
<h2 id="Experiment-amp-Table"><a href="#Experiment-amp-Table" class="headerlink" title="Experiment &amp; Table"></a>Experiment &amp; Table</h2><p><strong>1.模型表现</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117101056812.png" alt="image-20211117101056812"></p>
<ul>
<li>TiSASRec在6个数据集上达到了SOTA</li>
</ul>
<p><strong>2.Ablation Study</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117103132511.png" alt="image-20211117103132511"></p>
<ul>
<li>TiSASRec-R去掉了在K和V里去掉了position embedding（绝对位置）</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117103534252.png" alt="image-20211117103534252"></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117103553274.png" alt="image-20211117103553274"></p>
<ul>
<li>SASRec去掉了relative time interval（relation，相对时间间隔）</li>
</ul>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117114708312.png" alt="image-20211117114708312"></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117114729528.png" alt="image-20211117114729528"></p>
<ul>
<li>结果表明保留绝对位置和相对时间间隔时model performance最好</li>
</ul>
<p><strong>3.超参数实验</strong></p>
<p><strong>A.隐向量维度d</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117104027269.png" alt="image-20211117104027269"></p>
<ul>
<li>不同模型在不同数据集（<em>除了Games和Steam，why？</em>）上选择d={10，20，30，40，50}</li>
<li>基本上所给模型在所给数据集上都是d越大越好</li>
<li>在Beauty数据集比较特殊，MARank、Caser、TransRec的表现随着d增大在变差</li>
<li>所以最后选d=50</li>
</ul>
<p><strong>B. 序列最大长度n</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117104705615.png" alt="image-20211117104705615"></p>
<ul>
<li>n越大效果越好，并且在这两个数据集上SASRec表现比TiSASRec差且更快收敛。</li>
<li>所以最后选n=50</li>
<li><em>疑问：只选了MovieLens和Amazon CD&amp;Vinyl做实验，why？SASRec论文里选MovieLens-1m做实验的时候maxlen选的可是200，且performance比TiSASRec选50时好….这篇论文maxlen选的最大才50，why？</em></li>
</ul>
<p><strong>C.最大时间间隔k</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117105425551.png" alt="image-20211117105425551"></p>
<ul>
<li>k越大意味着要训练的参数越多</li>
<li>TiSASRec整体上更稳定，TiSASRec-R当k取合适时表现最好，但当k更大时表现变差。</li>
<li><em>疑问：ml-1m上比较稳定且permformance在提升，到最大值2048。但CD&amp;Vinyl上最好表现是k=256，但论文最后选的k=512</em></li>
</ul>
<p><strong>4.个性化时间间隔实验</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117110513024.png" alt="image-20211117110513024"></p>
<ul>
<li>Method（1）直接用时间戳作为特征，Method（2）使用没缩放的时间间隔，Method（3）使用个性化（根据每个用户最小时间间隔缩放后的）的时间间隔，即论文方法。</li>
<li>注意前两个方法没有使用时间戳裁剪 timestamps clip</li>
<li>Method（3）的performence最好</li>
</ul>
<p><strong>5.可视化</strong></p>
<p><img src="https://gitee.com/Guadzilla/img-hosting/raw/master/image-20211117111955529.png" alt="image-20211117111955529"></p>
<ul>
<li>Figure 7 表明预测时使用时间间隔产生的推荐不一样，而且好像更准确</li>
<li>Figure 8 是不同时间间隔的权重可视化<ul>
<li>小时间间隔的权重更大，说明更短期交互的物品对预测结果影响更大</li>
<li>(a)MovieLens是dense数据集，(b) CDs&amp;Vinyl是sparse数据集。左边绿的区域更大，说明dense数据集上预测需要更大范围的物品。</li>
<li>Amazon Beauty数据集没有明显的黄绿区域，说明这个数据集没有明显的序列模式，这也说明了为什么有些序列模型在该数据集上效果不是很好。</li>
</ul>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://aclanthology.org/N18-2074/">[1]Self-Attention with Relative Position Representations</a>)</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>序列推荐</tag>
        <tag>自注意力</tag>
        <tag>TiSASRec</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2021/11/17/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<hr>
<p>原paper：</p>
<p>源码解读：</p>
<hr>
<p>中译：</p>
<p>总结：</p>
<hr>
<span id="more"></span>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>question作者想解决什么问题？ </li>
</ul>
<ul>
<li>method作者通过什么理论/模型来解决这个问题？</li>
</ul>
<ul>
<li>answer作者给出的答案是什么？</li>
</ul>
<h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><ul>
<li>why作者为什么研究这个课题？    </li>
</ul>
<ul>
<li>how当前研究到了哪一阶段？</li>
</ul>
<ul>
<li>what作者基于什么样的假设（看不懂最后去查）？</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>优点 </li>
</ul>
<ul>
<li>缺点</li>
</ul>
<ul>
<li>展望</li>
</ul>
<h2 id="Dataset-amp-Metric"><a href="#Dataset-amp-Metric" class="headerlink" title="Dataset &amp; Metric"></a>Dataset &amp; Metric</h2><ul>
<li>数据来源 </li>
</ul>
<ul>
<li>重要指标 </li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul>
<li></li>
<li></li>
</ul>
<h2 id="Experiment-amp-Table"><a href="#Experiment-amp-Table" class="headerlink" title="Experiment &amp; Table"></a>Experiment &amp; Table</h2><ul>
<li></li>
<li></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
  </entry>
</search>
